
Scope of this document
======================

This document describes the User Interface \(UI\), both in functional terms
(what features it should include, what the behaviour should be) and
technical terms (how the code should be written, how the classes will
interact).


Definitions
===========

User Interface
: UI is a specific term that describes the presentation, interaction and
behaviour of graphic controls (windows, buttons, panels, etc) that contain
one another, launch events when they change state, and can be seen and often
modified by the user directly.

Component
: A component is a 2D entity with dimensions and properties. It can be
displayable or not. Components can also sometimes be containers for
other components. A component is a very abstract notion.

Control
: A control is a kind of component that can be displayed to screen, and
therefore seen by the user.

UI tree
: A UI tree is an arborescent structure containing components, where each
node is a container for its children. In order for this tree to be displayed,
the root node must be a Desktop, and must be inserted in a window system tree.
The same UI tree may exist in several bigger trees at the same time.

Desktop
: A desktop is a component that can contain applications. It is typically the
root of a UI tree, but does not have to be.

Window System
: A window system manages UI locally. It holds internal representations of the
UI windows as implemented in the client OS.


Component states
================
A component is always in a combination of the given states :
- csReady = 0x0
- csDestroying = 0x1 : The component is about to be destroyed
- csDesigning = 0x2 : currently manipulated by the form designer
- csClosing = 0x4 : The window is about to be closed // For a window only

    Atomic::Int<32> pState;
    inline bool destroying() const {return pState & csDestroying;}
    inline bool designing() const {return pState & csDesigning;}
    inline bool ready() const {return !(pState & (csClosing | csDestroying));}
    inline bool closing() const {return pState & csClosing;}  // UI::Window


Class hierarchy
===============

See ui_hierarchy.dot


Directory structure
===================
All classes relevant to a UI tree are stored in :
    "yuni/src/yuni/ui/"

Internal representations of UI windows are located in :
    "yuni/src/yuni/ui/local/"


UI modification
===============
Modifications to a UI component in a UI tree are done in batch using a
way similar to the following :

    { // Open a scope
    	// Lock the data, begin update
    	UI::UpdateLocker locker(listbox);
    
    	// Clear the list
    	listbox->clear();
    	// Add a million items in the list
    	for (unsigned int i = 0; i != 1000000; ++i)
    		*listbox += "Item";
    } // Update is done here when the locker falls out of scope


Data synchronization
====================
When a component is modified, it is added to a map sorted by its depth
in the tree. When refreshing, process this structure by updating
higher-depth components first. When refreshing a component, recurse on
each of its children, and check their existence in the map. If they
are in the map, remove them to avoid updating twice.

Example:

    Window_1
    |
     -> Panel_1
    |   |
    |    -> Button_1 *
    |
     -> Panel_2 *
        |
         -> CheckBox_1 *
        |
         -> Button_2


Supposing components with \* are modified, the algorithm will process
them as follows :

    - Step 1:
      modified : [ [ 2 , [ Panel_2 ] ] , [ 3, [ Button_1 , CheckBox_1 ] ] ]
      update Panel_2
        apply modifications
    	remove it from "modified"
        update Panel_2's children:
          update CheckBox_1
            apply modifications
    	    remove it from "modified"
    	    it has no child
    	  update Button_2
            apply possible inherited modifications
    	    it is not in "modified"
    	    it has no child

    - Step 2:
      modified : [ [ 3, [ Button_1 ] ] ]
      update Button_1
        it has no child
