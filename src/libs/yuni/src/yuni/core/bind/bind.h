#ifndef __YUNI_CORE_BIND_BIND_H__
# define __YUNI_CORE_BIND_BIND_H__

# include "../../yuni.h"
# include "../../thread/policy.h"
# include "../static/types.h"
# include "../static/assert.h"
# include "../static/remove.h"
# include "../smartptr.h"
# include "traits.h"
# include "../dynamiclibrary/symbol.h"


/*!
** \internal This file is automatically generated by 'bind.h.generator.hpp'.
** Please make any modifications you wish to this script instead of
** this file, as they will otherwise be lost at the next generation.
*/


namespace Yuni
{


	/*!
	** \brief A delegate implementation
	**
	** How to bind a mere function :
	** \code
	** #include <iostream>
	** #include <yuni/bind.h>
	**
	** static int Foo(int value)
	** {
	** 	std::cout << "Foo: " << value << std::endl;
	** 	return 0;
	** }
	**
	** int main()
	** {
	** 	Yuni::Bind<int (int)> callback;
	** 	callback.bind(&Foo);
	** 	callback(42);
	** 	callback(61);
	** 	callback(-1)
	** 	return 0;
	** }
	** \endcode
	**
	** How to bind a member of an object :
	** \code
	** #include <iostream>
	** #include <yuni/bind.h>
	**
	** class Foo
	** {
	** public:
	**	int bar(int value)
	**	{
	** 		std::cout << "Foo::bar  : " << value << std::endl;
	** 		return 0;
	**	}
	**	int bar2(int value)
	**	{
	** 		std::cout << "Foo::bar2 : " << value << std::endl;
	** 		return 0;
	**	}
	** };
	**
	** int main()
	** {
	**	Foo foo;
	** 	Yuni::Bind<int (int)> callback;
	** 	callback.bind(foo, &Foo::bar);
	** 	callback(42);
	** 	callback(61);
	** 	callback(-1)
	** 	callback.bind(foo, &Foo::bar2);
	** 	callback(42);
	** 	callback(61);
	** 	callback(-1)
	** 	return 0;
	** }
	** \endcode
	**
	** This class is thread-safe, this is guaranteed by the use of smartptr.
	**
	** \note This class does not take care of deleted objects. It is the responsibility
	** of the user to unbind the delegate before the linked object is delete and/or
	** to not invoke the delegate when the object does not exist.
	**
	** \note It is safe to provide a null pointer when binding the delegate
	** \note It is always safe to invoke the delegate when unbound.
	**
	** \tparam P The prototype of the targetted function/member
	*/
	template<class P = void (), class Dummy = void>
	class Bind
	{
	public:
		// This class can not be used like that. We must use one the specialization
		// (see below).
		// All definitions in this class are only here for the documentation
		YUNI_STATIC_ASSERT(false, Bind_BadFunctionOrMemberSignature);

	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Copy constructor
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

	}; // class Bind<>














	//
	// --- Specializations for Bind<> ---
	//




	/*
	** \brief Bind to a function/member with 0 argument (Specialization)
	*/
	template<class R>
	class Bind<R (), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (), void> Type;
		//! The Bind Type
		typedef Bind<R (), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)();
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)();
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)() const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 0,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 0 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)());


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)());

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)());
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)() const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)() const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke() const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () () const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)());
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)()) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback();
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid();

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R()> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R()>






	/*
	** \brief Bind to a function/member with 0 argument (Specialization)
	*/
	template<class R>
	class Bind<R (*)(), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)();
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)();
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)() const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 0,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 0 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)());


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)());

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)());
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)() const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)() const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke() const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () () const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)());
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)()) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback();
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid();

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R()> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R()>






	/*
	** \brief Bind to a function/member with 0 argument (Specialization)
	*/
	template<class ClassT, class R>
	class Bind<R (ClassT::*)(), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)();
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)();
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)() const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 0,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 0 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)());


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)());

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)());
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)() const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)() const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke() const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () () const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)());
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)()) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback();
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid();

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R()> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R()>






	/*
	** \brief Bind to a function/member with 1 argument (Specialization)
	*/
	template<class R, class A0>
	class Bind<R (A0), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0), void> Type;
		//! The Bind Type
		typedef Bind<R (A0), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 1,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 1 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0)>






	/*
	** \brief Bind to a function/member with 1 argument (Specialization)
	*/
	template<class R, class A0>
	class Bind<R (*)(A0), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 1,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 1 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0)>






	/*
	** \brief Bind to a function/member with 1 argument (Specialization)
	*/
	template<class ClassT, class R, class A0>
	class Bind<R (ClassT::*)(A0), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 1,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 1 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0)>






	/*
	** \brief Bind to a function/member with 2 arguments (Specialization)
	*/
	template<class R, class A0, class A1>
	class Bind<R (A0, A1), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 2,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 2 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1)>






	/*
	** \brief Bind to a function/member with 2 arguments (Specialization)
	*/
	template<class R, class A0, class A1>
	class Bind<R (*)(A0, A1), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 2,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 2 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1)>






	/*
	** \brief Bind to a function/member with 2 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1>
	class Bind<R (ClassT::*)(A0, A1), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 2,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 2 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1)>






	/*
	** \brief Bind to a function/member with 3 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2>
	class Bind<R (A0, A1, A2), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 3,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 3 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2)>






	/*
	** \brief Bind to a function/member with 3 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2>
	class Bind<R (*)(A0, A1, A2), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 3,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 3 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2)>






	/*
	** \brief Bind to a function/member with 3 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2>
	class Bind<R (ClassT::*)(A0, A1, A2), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 3,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 3 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2)>






	/*
	** \brief Bind to a function/member with 4 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3>
	class Bind<R (A0, A1, A2, A3), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 4,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 4 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3)>






	/*
	** \brief Bind to a function/member with 4 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3>
	class Bind<R (*)(A0, A1, A2, A3), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 4,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 4 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3)>






	/*
	** \brief Bind to a function/member with 4 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	class Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 4,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 4 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3)>






	/*
	** \brief Bind to a function/member with 5 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4>
	class Bind<R (A0, A1, A2, A3, A4), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 5,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 5 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4)>






	/*
	** \brief Bind to a function/member with 5 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4>
	class Bind<R (*)(A0, A1, A2, A3, A4), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 5,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 5 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4)>






	/*
	** \brief Bind to a function/member with 5 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	class Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 5,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 5 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4)>






	/*
	** \brief Bind to a function/member with 6 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	class Bind<R (A0, A1, A2, A3, A4, A5), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 6,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 6 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5)>






	/*
	** \brief Bind to a function/member with 6 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	class Bind<R (*)(A0, A1, A2, A3, A4, A5), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 6,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 6 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5)>






	/*
	** \brief Bind to a function/member with 6 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	class Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 6,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 6 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5)>






	/*
	** \brief Bind to a function/member with 7 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 7,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 7 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6)>






	/*
	** \brief Bind to a function/member with 7 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	class Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 7,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 7 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6)>






	/*
	** \brief Bind to a function/member with 7 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	class Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 7,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 7 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6)>






	/*
	** \brief Bind to a function/member with 8 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 8,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 8 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7)>






	/*
	** \brief Bind to a function/member with 8 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	class Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 8,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 8 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7)>






	/*
	** \brief Bind to a function/member with 8 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	class Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 8,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 8 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7)>






	/*
	** \brief Bind to a function/member with 9 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 9,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 9 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>






	/*
	** \brief Bind to a function/member with 9 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	class Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 9,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 9 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>






	/*
	** \brief Bind to a function/member with 9 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	class Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 9,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 9 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>






	/*
	** \brief Bind to a function/member with 10 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 10,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 10 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>






	/*
	** \brief Bind to a function/member with 10 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	class Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 10,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 10 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>






	/*
	** \brief Bind to a function/member with 10 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	class Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 10,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 10 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>






	/*
	** \brief Bind to a function/member with 11 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 11,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 11 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>






	/*
	** \brief Bind to a function/member with 11 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	class Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 11,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 11 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>






	/*
	** \brief Bind to a function/member with 11 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	class Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 11,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 11 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>






	/*
	** \brief Bind to a function/member with 12 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 12,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 12 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>






	/*
	** \brief Bind to a function/member with 12 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	class Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 12,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 12 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>






	/*
	** \brief Bind to a function/member with 12 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	class Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 12,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 12 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>






	/*
	** \brief Bind to a function/member with 13 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 13,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 13 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>






	/*
	** \brief Bind to a function/member with 13 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	class Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 13,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 13 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>






	/*
	** \brief Bind to a function/member with 13 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	class Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 13,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 13 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>






	/*
	** \brief Bind to a function/member with 14 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 14,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 14 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>






	/*
	** \brief Bind to a function/member with 14 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	class Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 14,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 14 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>






	/*
	** \brief Bind to a function/member with 14 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	class Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 14,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 14 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>






	/*
	** \brief Bind to a function/member with 15 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 15,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 15 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>






	/*
	** \brief Bind to a function/member with 15 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	class Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 15,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 15 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>






	/*
	** \brief Bind to a function/member with 15 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	class Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 15,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 15 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>






	/*
	** \brief Bind to a function/member with 16 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 16,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 16 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>






	/*
	** \brief Bind to a function/member with 16 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	class Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 16,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 16 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>






	/*
	** \brief Bind to a function/member with 16 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	class Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 16,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 16 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Constructor from a library symbol
		*/
		Bind(const Yuni::DynamicLibrary::Symbol& symbol);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		*/
		void bind(const Yuni::DynamicLibrary::Symbol& symbol);
		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend struct Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>











} // namespace Yuni

# include "bind.hxx"


template<class P, class DummyT>
inline std::ostream& operator << (std::ostream& out, const Yuni::Bind<P,DummyT>& rhs)
{
	rhs.print(out);
	return out;
}


// Comparison with any pointer-to-object
template<class U, class P, class DummyT>
inline bool operator == (const U* object, const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == object);
}

// Comparison with any pointer-to-object
template<class U, class P, class DummyT>
inline bool operator != (const U* object, const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != object);
}



template<class R, class P, class DummyT>
inline bool operator == (R (*pointer)(), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT>
inline bool operator != (R (*pointer)(), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0>
inline bool operator == (R (*pointer)(A0), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0>
inline bool operator != (R (*pointer)(A0), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1>
inline bool operator == (R (*pointer)(A0, A1), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1>
inline bool operator != (R (*pointer)(A0, A1), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2>
inline bool operator == (R (*pointer)(A0, A1, A2), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2>
inline bool operator != (R (*pointer)(A0, A1, A2), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3>
inline bool operator == (R (*pointer)(A0, A1, A2, A3), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3>
inline bool operator != (R (*pointer)(A0, A1, A2, A3), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



#endif // __YUNI_CORE_BIND_BIND_H__
