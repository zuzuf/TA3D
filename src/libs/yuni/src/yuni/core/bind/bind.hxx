#ifndef __YUNI_CORE_BIND_BIND_HXX__
# define __YUNI_CORE_BIND_BIND_HXX__


/*!
** \internal This file is automatically generated by 'bind.hxx.generator.hpp'.
** Please make any modifications you wish to this script instead of
** this file, as they will otherwise be lost at the next generation.
*/


namespace Yuni
{




	// Constructor
	template<class R>
	inline Bind<R (), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R>
	inline Bind<R (), void>::Bind(const Bind<R (), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R>
	inline Bind<R (), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R>
	inline Bind<R (), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R>
	inline void Bind<R (), void>::bind(R (*pointer)())
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R ()>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R>
	inline void Bind<R (), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R ()>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R>
	template<class U>
	inline void Bind<R (), void>::bind(R (*pointer)(U),
		typename Bind<R (), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R>
	template<class C>
	void Bind<R (), void>::bind(C* c, R (C::*member)())
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C>
	void Bind<R (), void>::bind(const C* c, R (C::*member)() const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)())
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)() const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(U),
		typename Bind<R (), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(U) const,
		typename Bind<R (), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R>
	template<class U, class C>
	void Bind<R (), void>::bind(C* c, R (C::*member)(U),
		typename Bind<R (), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	template<class U, class C>
	void Bind<R (), void>::bind(const C* c, R (C::*member)(U) const,
		typename Bind<R (), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	inline void Bind<R (), void>::bind(const Bind<R (), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R>
	inline void Bind<R (), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R>
	inline void Bind<R (), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke();
	}






	template<class R>
	inline R Bind<R (), void>::invoke() const
	{
		return pHolder->invoke();
	}


	template<class R>
	inline R Bind<R (), void>::operator () () const
	{
		return pHolder->invoke();
	}


	template<class R>
	inline R Bind<R (), void>::emptyCallback()
	{
		return R();
	}

	template<class R>
	inline const void* Bind<R (), void>::object() const
	{
		return pHolder->object();
	}

	template<class R>
	inline const IEventObserverBase* Bind<R (), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R>
	inline bool Bind<R (), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R>
	inline bool Bind<R (), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R>
	inline void Bind<R (), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R>
	inline void Bind<R (), void>::emptyCallbackReturnsVoid()
	{
		/* Do nothing */
	}






	template<class R>
	inline Bind<R (), void>& Bind<R (), void>::operator = (R (*pointer)())
	{
		bind(pointer);
		return *this;
	}


	template<class R>
	inline Bind<R (), void>& Bind<R (), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R>
	inline Bind<R (), void>& Bind<R (), void>::operator = (const Bind<R (), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R>
	inline bool Bind<R (), void>::operator == (R (*pointer)()) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R>
	template<class U>
	inline bool Bind<R (), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R>
	inline Bind<R (*)(), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R>
	inline Bind<R (*)(), void>::Bind(const Bind<R (*)(), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R>
	inline Bind<R (*)(), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R>
	inline Bind<R (*)(), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R>
	inline void Bind<R (*)(), void>::bind(R (*pointer)())
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R ()>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R>
	inline void Bind<R (*)(), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R ()>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R>
	template<class U>
	inline void Bind<R (*)(), void>::bind(R (*pointer)(U),
		typename Bind<R (*)(), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R>
	template<class C>
	void Bind<R (*)(), void>::bind(C* c, R (C::*member)())
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C>
	void Bind<R (*)(), void>::bind(const C* c, R (C::*member)() const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)())
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)() const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(U),
		typename Bind<R (*)(), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(U) const,
		typename Bind<R (*)(), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R>
	template<class U, class C>
	void Bind<R (*)(), void>::bind(C* c, R (C::*member)(U),
		typename Bind<R (*)(), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	template<class U, class C>
	void Bind<R (*)(), void>::bind(const C* c, R (C::*member)(U) const,
		typename Bind<R (*)(), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	inline void Bind<R (*)(), void>::bind(const Bind<R (*)(), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R>
	inline void Bind<R (*)(), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R>
	inline void Bind<R (*)(), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke();
	}






	template<class R>
	inline R Bind<R (*)(), void>::invoke() const
	{
		return pHolder->invoke();
	}


	template<class R>
	inline R Bind<R (*)(), void>::operator () () const
	{
		return pHolder->invoke();
	}


	template<class R>
	inline R Bind<R (*)(), void>::emptyCallback()
	{
		return R();
	}

	template<class R>
	inline const void* Bind<R (*)(), void>::object() const
	{
		return pHolder->object();
	}

	template<class R>
	inline const IEventObserverBase* Bind<R (*)(), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R>
	inline bool Bind<R (*)(), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R>
	inline bool Bind<R (*)(), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R>
	inline void Bind<R (*)(), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R>
	inline void Bind<R (*)(), void>::emptyCallbackReturnsVoid()
	{
		/* Do nothing */
	}






	template<class R>
	inline Bind<R (*)(), void>& Bind<R (*)(), void>::operator = (R (*pointer)())
	{
		bind(pointer);
		return *this;
	}


	template<class R>
	inline Bind<R (*)(), void>& Bind<R (*)(), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R>
	inline Bind<R (*)(), void>& Bind<R (*)(), void>::operator = (const Bind<R (*)(), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R>
	inline bool Bind<R (*)(), void>::operator == (R (*pointer)()) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R>
	template<class U>
	inline bool Bind<R (*)(), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>::Bind(const Bind<R (ClassT::*)(), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::bind(R (*pointer)())
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R ()>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R ()>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R>
	template<class U>
	inline void Bind<R (ClassT::*)(), ClassT>::bind(R (*pointer)(U),
		typename Bind<R (ClassT::*)(), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R>
	template<class C>
	void Bind<R (ClassT::*)(), ClassT>::bind(C* c, R (C::*member)())
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R>
	template<class C>
	void Bind<R (ClassT::*)(), ClassT>::bind(const C* c, R (C::*member)() const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)())
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)() const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(U),
		typename Bind<R (ClassT::*)(), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(U) const,
		typename Bind<R (ClassT::*)(), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R>
	template<class U, class C>
	void Bind<R (ClassT::*)(), ClassT>::bind(C* c, R (C::*member)(U),
		typename Bind<R (ClassT::*)(), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R>
	template<class U, class C>
	void Bind<R (ClassT::*)(), ClassT>::bind(const C* c, R (C::*member)(U) const,
		typename Bind<R (ClassT::*)(), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::bind(const Bind<R (ClassT::*)(), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke();
	}






	template<class ClassT, class R>
	inline R Bind<R (ClassT::*)(), ClassT>::invoke() const
	{
		return pHolder->invoke();
	}


	template<class ClassT, class R>
	inline R Bind<R (ClassT::*)(), ClassT>::operator () () const
	{
		return pHolder->invoke();
	}


	template<class ClassT, class R>
	inline R Bind<R (ClassT::*)(), ClassT>::emptyCallback()
	{
		return R();
	}

	template<class ClassT, class R>
	inline const void* Bind<R (ClassT::*)(), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R>
	inline const IEventObserverBase* Bind<R (ClassT::*)(), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R>
	inline bool Bind<R (ClassT::*)(), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R>
	inline bool Bind<R (ClassT::*)(), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::emptyCallbackReturnsVoid()
	{
		/* Do nothing */
	}






	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>& Bind<R (ClassT::*)(), ClassT>::operator = (R (*pointer)())
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>& Bind<R (ClassT::*)(), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>& Bind<R (ClassT::*)(), ClassT>::operator = (const Bind<R (ClassT::*)(), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R>
	inline bool Bind<R (ClassT::*)(), ClassT>::operator == (R (*pointer)()) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R>
	template<class U>
	inline bool Bind<R (ClassT::*)(), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0>
	inline Bind<R (A0), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0>
	inline Bind<R (A0), void>::Bind(const Bind<R (A0), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0>
	inline Bind<R (A0), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0>
	inline Bind<R (A0), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0>
	inline void Bind<R (A0), void>::bind(R (*pointer)(A0))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0>
	inline void Bind<R (A0), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0>
	template<class U>
	inline void Bind<R (A0), void>::bind(R (*pointer)(A0, U),
		typename Bind<R (A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0>
	template<class C>
	void Bind<R (A0), void>::bind(C* c, R (C::*member)(A0))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C>
	void Bind<R (A0), void>::bind(const C* c, R (C::*member)(A0) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, U),
		typename Bind<R (A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, U) const,
		typename Bind<R (A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0>
	template<class U, class C>
	void Bind<R (A0), void>::bind(C* c, R (C::*member)(A0, U),
		typename Bind<R (A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	template<class U, class C>
	void Bind<R (A0), void>::bind(const C* c, R (C::*member)(A0, U) const,
		typename Bind<R (A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	inline void Bind<R (A0), void>::bind(const Bind<R (A0), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0>
	inline void Bind<R (A0), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0>
	inline void Bind<R (A0), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0));
	}






	template<class R, class A0>
	inline R Bind<R (A0), void>::invoke(A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class R, class A0>
	inline R Bind<R (A0), void>::operator () (A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class R, class A0>
	inline R Bind<R (A0), void>::emptyCallback(A0)
	{
		return R();
	}

	template<class R, class A0>
	inline const void* Bind<R (A0), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0>
	inline const IEventObserverBase* Bind<R (A0), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0>
	inline bool Bind<R (A0), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0>
	inline bool Bind<R (A0), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0>
	inline void Bind<R (A0), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0>
	inline void Bind<R (A0), void>::emptyCallbackReturnsVoid(A0)
	{
		/* Do nothing */
	}






	template<class R, class A0>
	inline Bind<R (A0), void>& Bind<R (A0), void>::operator = (R (*pointer)(A0))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0>
	inline Bind<R (A0), void>& Bind<R (A0), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0>
	inline Bind<R (A0), void>& Bind<R (A0), void>::operator = (const Bind<R (A0), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0>
	inline bool Bind<R (A0), void>::operator == (R (*pointer)(A0)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0>
	template<class U>
	inline bool Bind<R (A0), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0>
	inline Bind<R (*)(A0), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0>
	inline Bind<R (*)(A0), void>::Bind(const Bind<R (*)(A0), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0>
	inline Bind<R (*)(A0), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0>
	inline Bind<R (*)(A0), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::bind(R (*pointer)(A0))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0>
	template<class U>
	inline void Bind<R (*)(A0), void>::bind(R (*pointer)(A0, U),
		typename Bind<R (*)(A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0>
	template<class C>
	void Bind<R (*)(A0), void>::bind(C* c, R (C::*member)(A0))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C>
	void Bind<R (*)(A0), void>::bind(const C* c, R (C::*member)(A0) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, U),
		typename Bind<R (*)(A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, U) const,
		typename Bind<R (*)(A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0>
	template<class U, class C>
	void Bind<R (*)(A0), void>::bind(C* c, R (C::*member)(A0, U),
		typename Bind<R (*)(A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	template<class U, class C>
	void Bind<R (*)(A0), void>::bind(const C* c, R (C::*member)(A0, U) const,
		typename Bind<R (*)(A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::bind(const Bind<R (*)(A0), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0));
	}






	template<class R, class A0>
	inline R Bind<R (*)(A0), void>::invoke(A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class R, class A0>
	inline R Bind<R (*)(A0), void>::operator () (A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class R, class A0>
	inline R Bind<R (*)(A0), void>::emptyCallback(A0)
	{
		return R();
	}

	template<class R, class A0>
	inline const void* Bind<R (*)(A0), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0>
	inline const IEventObserverBase* Bind<R (*)(A0), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0>
	inline bool Bind<R (*)(A0), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0>
	inline bool Bind<R (*)(A0), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::emptyCallbackReturnsVoid(A0)
	{
		/* Do nothing */
	}






	template<class R, class A0>
	inline Bind<R (*)(A0), void>& Bind<R (*)(A0), void>::operator = (R (*pointer)(A0))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0>
	inline Bind<R (*)(A0), void>& Bind<R (*)(A0), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0>
	inline Bind<R (*)(A0), void>& Bind<R (*)(A0), void>::operator = (const Bind<R (*)(A0), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0>
	inline bool Bind<R (*)(A0), void>::operator == (R (*pointer)(A0)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0>
	template<class U>
	inline bool Bind<R (*)(A0), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>::Bind(const Bind<R (ClassT::*)(A0), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::bind(R (*pointer)(A0))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0>
	template<class U>
	inline void Bind<R (ClassT::*)(A0), ClassT>::bind(R (*pointer)(A0, U),
		typename Bind<R (ClassT::*)(A0), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0>
	template<class C>
	void Bind<R (ClassT::*)(A0), ClassT>::bind(C* c, R (C::*member)(A0))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0>
	template<class C>
	void Bind<R (ClassT::*)(A0), ClassT>::bind(const C* c, R (C::*member)(A0) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, U),
		typename Bind<R (ClassT::*)(A0), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, U) const,
		typename Bind<R (ClassT::*)(A0), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0), ClassT>::bind(C* c, R (C::*member)(A0, U),
		typename Bind<R (ClassT::*)(A0), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0), ClassT>::bind(const C* c, R (C::*member)(A0, U) const,
		typename Bind<R (ClassT::*)(A0), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::bind(const Bind<R (ClassT::*)(A0), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0));
	}






	template<class ClassT, class R, class A0>
	inline R Bind<R (ClassT::*)(A0), ClassT>::invoke(A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class ClassT, class R, class A0>
	inline R Bind<R (ClassT::*)(A0), ClassT>::operator () (A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class ClassT, class R, class A0>
	inline R Bind<R (ClassT::*)(A0), ClassT>::emptyCallback(A0)
	{
		return R();
	}

	template<class ClassT, class R, class A0>
	inline const void* Bind<R (ClassT::*)(A0), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0>
	inline bool Bind<R (ClassT::*)(A0), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0>
	inline bool Bind<R (ClassT::*)(A0), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::emptyCallbackReturnsVoid(A0)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>& Bind<R (ClassT::*)(A0), ClassT>::operator = (R (*pointer)(A0))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>& Bind<R (ClassT::*)(A0), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>& Bind<R (ClassT::*)(A0), ClassT>::operator = (const Bind<R (ClassT::*)(A0), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0>
	inline bool Bind<R (ClassT::*)(A0), ClassT>::operator == (R (*pointer)(A0)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>::Bind(const Bind<R (A0, A1), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::bind(R (*pointer)(A0, A1))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1>
	template<class U>
	inline void Bind<R (A0, A1), void>::bind(R (*pointer)(A0, A1, U),
		typename Bind<R (A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1>
	template<class C>
	void Bind<R (A0, A1), void>::bind(C* c, R (C::*member)(A0, A1))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C>
	void Bind<R (A0, A1), void>::bind(const C* c, R (C::*member)(A0, A1) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, U),
		typename Bind<R (A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (A0, A1), void>::bind(C* c, R (C::*member)(A0, A1, U),
		typename Bind<R (A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (A0, A1), void>::bind(const C* c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::bind(const Bind<R (A0, A1), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1));
	}






	template<class R, class A0, class A1>
	inline R Bind<R (A0, A1), void>::invoke(A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class R, class A0, class A1>
	inline R Bind<R (A0, A1), void>::operator () (A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class R, class A0, class A1>
	inline R Bind<R (A0, A1), void>::emptyCallback(A0, A1)
	{
		return R();
	}

	template<class R, class A0, class A1>
	inline const void* Bind<R (A0, A1), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1>
	inline const IEventObserverBase* Bind<R (A0, A1), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1>
	inline bool Bind<R (A0, A1), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1>
	inline bool Bind<R (A0, A1), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::emptyCallbackReturnsVoid(A0, A1)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>& Bind<R (A0, A1), void>::operator = (R (*pointer)(A0, A1))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>& Bind<R (A0, A1), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>& Bind<R (A0, A1), void>::operator = (const Bind<R (A0, A1), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1>
	inline bool Bind<R (A0, A1), void>::operator == (R (*pointer)(A0, A1)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1>
	template<class U>
	inline bool Bind<R (A0, A1), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>::Bind(const Bind<R (*)(A0, A1), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::bind(R (*pointer)(A0, A1))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1>
	template<class U>
	inline void Bind<R (*)(A0, A1), void>::bind(R (*pointer)(A0, A1, U),
		typename Bind<R (*)(A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1>
	template<class C>
	void Bind<R (*)(A0, A1), void>::bind(C* c, R (C::*member)(A0, A1))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C>
	void Bind<R (*)(A0, A1), void>::bind(const C* c, R (C::*member)(A0, A1) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, U),
		typename Bind<R (*)(A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (*)(A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (*)(A0, A1), void>::bind(C* c, R (C::*member)(A0, A1, U),
		typename Bind<R (*)(A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (*)(A0, A1), void>::bind(const C* c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (*)(A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::bind(const Bind<R (*)(A0, A1), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1));
	}






	template<class R, class A0, class A1>
	inline R Bind<R (*)(A0, A1), void>::invoke(A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class R, class A0, class A1>
	inline R Bind<R (*)(A0, A1), void>::operator () (A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class R, class A0, class A1>
	inline R Bind<R (*)(A0, A1), void>::emptyCallback(A0, A1)
	{
		return R();
	}

	template<class R, class A0, class A1>
	inline const void* Bind<R (*)(A0, A1), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1>
	inline const IEventObserverBase* Bind<R (*)(A0, A1), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1>
	inline bool Bind<R (*)(A0, A1), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1>
	inline bool Bind<R (*)(A0, A1), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::emptyCallbackReturnsVoid(A0, A1)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>& Bind<R (*)(A0, A1), void>::operator = (R (*pointer)(A0, A1))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>& Bind<R (*)(A0, A1), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>& Bind<R (*)(A0, A1), void>::operator = (const Bind<R (*)(A0, A1), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1>
	inline bool Bind<R (*)(A0, A1), void>::operator == (R (*pointer)(A0, A1)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1>
	template<class U>
	inline bool Bind<R (*)(A0, A1), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(R (*pointer)(A0, A1))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(R (*pointer)(A0, A1, U),
		typename Bind<R (ClassT::*)(A0, A1), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(C* c, R (C::*member)(A0, A1))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const C* c, R (C::*member)(A0, A1) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, U),
		typename Bind<R (ClassT::*)(A0, A1), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (ClassT::*)(A0, A1), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(C* c, R (C::*member)(A0, A1, U),
		typename Bind<R (ClassT::*)(A0, A1), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const C* c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (ClassT::*)(A0, A1), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1));
	}






	template<class ClassT, class R, class A0, class A1>
	inline R Bind<R (ClassT::*)(A0, A1), ClassT>::invoke(A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class ClassT, class R, class A0, class A1>
	inline R Bind<R (ClassT::*)(A0, A1), ClassT>::operator () (A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class ClassT, class R, class A0, class A1>
	inline R Bind<R (ClassT::*)(A0, A1), ClassT>::emptyCallback(A0, A1)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1>
	inline const void* Bind<R (ClassT::*)(A0, A1), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1>
	inline bool Bind<R (ClassT::*)(A0, A1), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1>
	inline bool Bind<R (ClassT::*)(A0, A1), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::emptyCallbackReturnsVoid(A0, A1)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>& Bind<R (ClassT::*)(A0, A1), ClassT>::operator = (R (*pointer)(A0, A1))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>& Bind<R (ClassT::*)(A0, A1), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>& Bind<R (ClassT::*)(A0, A1), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1>
	inline bool Bind<R (ClassT::*)(A0, A1), ClassT>::operator == (R (*pointer)(A0, A1)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>::Bind(const Bind<R (A0, A1, A2), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::bind(R (*pointer)(A0, A1, A2))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2>
	template<class U>
	inline void Bind<R (A0, A1, A2), void>::bind(R (*pointer)(A0, A1, A2, U),
		typename Bind<R (A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (A0, A1, A2), void>::bind(C* c, R (C::*member)(A0, A1, A2))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (A0, A1, A2), void>::bind(const C* c, R (C::*member)(A0, A1, A2) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (A0, A1, A2), void>::bind(C* c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (A0, A1, A2), void>::bind(const C* c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::bind(const Bind<R (A0, A1, A2), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2));
	}






	template<class R, class A0, class A1, class A2>
	inline R Bind<R (A0, A1, A2), void>::invoke(A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class R, class A0, class A1, class A2>
	inline R Bind<R (A0, A1, A2), void>::operator () (A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class R, class A0, class A1, class A2>
	inline R Bind<R (A0, A1, A2), void>::emptyCallback(A0, A1, A2)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2>
	inline const void* Bind<R (A0, A1, A2), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2>
	inline const IEventObserverBase* Bind<R (A0, A1, A2), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (A0, A1, A2), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (A0, A1, A2), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::emptyCallbackReturnsVoid(A0, A1, A2)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>& Bind<R (A0, A1, A2), void>::operator = (R (*pointer)(A0, A1, A2))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>& Bind<R (A0, A1, A2), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>& Bind<R (A0, A1, A2), void>::operator = (const Bind<R (A0, A1, A2), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (A0, A1, A2), void>::operator == (R (*pointer)(A0, A1, A2)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2>
	template<class U>
	inline bool Bind<R (A0, A1, A2), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>::Bind(const Bind<R (*)(A0, A1, A2), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::bind(R (*pointer)(A0, A1, A2))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2), void>::bind(R (*pointer)(A0, A1, A2, U),
		typename Bind<R (*)(A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (*)(A0, A1, A2), void>::bind(C* c, R (C::*member)(A0, A1, A2))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (*)(A0, A1, A2), void>::bind(const C* c, R (C::*member)(A0, A1, A2) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (*)(A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (*)(A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2), void>::bind(C* c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (*)(A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2), void>::bind(const C* c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (*)(A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::bind(const Bind<R (*)(A0, A1, A2), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2));
	}






	template<class R, class A0, class A1, class A2>
	inline R Bind<R (*)(A0, A1, A2), void>::invoke(A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class R, class A0, class A1, class A2>
	inline R Bind<R (*)(A0, A1, A2), void>::operator () (A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class R, class A0, class A1, class A2>
	inline R Bind<R (*)(A0, A1, A2), void>::emptyCallback(A0, A1, A2)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2>
	inline const void* Bind<R (*)(A0, A1, A2), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (*)(A0, A1, A2), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (*)(A0, A1, A2), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::emptyCallbackReturnsVoid(A0, A1, A2)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>& Bind<R (*)(A0, A1, A2), void>::operator = (R (*pointer)(A0, A1, A2))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>& Bind<R (*)(A0, A1, A2), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>& Bind<R (*)(A0, A1, A2), void>::operator = (const Bind<R (*)(A0, A1, A2), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (*)(A0, A1, A2), void>::operator == (R (*pointer)(A0, A1, A2)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(R (*pointer)(A0, A1, A2))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(R (*pointer)(A0, A1, A2, U),
		typename Bind<R (ClassT::*)(A0, A1, A2), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (ClassT::*)(A0, A1, A2), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (ClassT::*)(A0, A1, A2), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2));
	}






	template<class ClassT, class R, class A0, class A1, class A2>
	inline R Bind<R (ClassT::*)(A0, A1, A2), ClassT>::invoke(A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline R Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator () (A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline R Bind<R (ClassT::*)(A0, A1, A2), ClassT>::emptyCallback(A0, A1, A2)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2>
	inline bool Bind<R (ClassT::*)(A0, A1, A2), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2>
	inline bool Bind<R (ClassT::*)(A0, A1, A2), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>& Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator = (R (*pointer)(A0, A1, A2))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>& Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>& Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline bool Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator == (R (*pointer)(A0, A1, A2)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>::Bind(const Bind<R (A0, A1, A2, A3), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::bind(R (*pointer)(A0, A1, A2, A3))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3), void>::bind(R (*pointer)(A0, A1, A2, A3, U),
		typename Bind<R (A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (A0, A1, A2, A3), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (A0, A1, A2, A3), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::bind(const Bind<R (A0, A1, A2, A3), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3));
	}






	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (A0, A1, A2, A3), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (A0, A1, A2, A3), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (A0, A1, A2, A3), void>::emptyCallback(A0, A1, A2, A3)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline const void* Bind<R (A0, A1, A2, A3), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (A0, A1, A2, A3), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (A0, A1, A2, A3), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>& Bind<R (A0, A1, A2, A3), void>::operator = (R (*pointer)(A0, A1, A2, A3))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>& Bind<R (A0, A1, A2, A3), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>& Bind<R (A0, A1, A2, A3), void>::operator = (const Bind<R (A0, A1, A2, A3), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (A0, A1, A2, A3), void>::operator == (R (*pointer)(A0, A1, A2, A3)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>::Bind(const Bind<R (*)(A0, A1, A2, A3), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::bind(R (*pointer)(A0, A1, A2, A3))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::bind(R (*pointer)(A0, A1, A2, A3, U),
		typename Bind<R (*)(A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (*)(A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (*)(A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (*)(A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (*)(A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::bind(const Bind<R (*)(A0, A1, A2, A3), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3));
	}






	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (*)(A0, A1, A2, A3), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (*)(A0, A1, A2, A3), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (*)(A0, A1, A2, A3), void>::emptyCallback(A0, A1, A2, A3)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline const void* Bind<R (*)(A0, A1, A2, A3), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (*)(A0, A1, A2, A3), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (*)(A0, A1, A2, A3), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>& Bind<R (*)(A0, A1, A2, A3), void>::operator = (R (*pointer)(A0, A1, A2, A3))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>& Bind<R (*)(A0, A1, A2, A3), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>& Bind<R (*)(A0, A1, A2, A3), void>::operator = (const Bind<R (*)(A0, A1, A2, A3), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (*)(A0, A1, A2, A3), void>::operator == (R (*pointer)(A0, A1, A2, A3)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(R (*pointer)(A0, A1, A2, A3))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::emptyCallback(A0, A1, A2, A3)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>::Bind(const Bind<R (A0, A1, A2, A3, A4), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::bind(R (*pointer)(A0, A1, A2, A3, A4))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, U),
		typename Bind<R (A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::bind(const Bind<R (A0, A1, A2, A3, A4), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (A0, A1, A2, A3, A4), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (A0, A1, A2, A3, A4), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (A0, A1, A2, A3, A4), void>::emptyCallback(A0, A1, A2, A3, A4)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline const void* Bind<R (A0, A1, A2, A3, A4), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (A0, A1, A2, A3, A4), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (A0, A1, A2, A3, A4), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>& Bind<R (A0, A1, A2, A3, A4), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>& Bind<R (A0, A1, A2, A3, A4), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>& Bind<R (A0, A1, A2, A3, A4), void>::operator = (const Bind<R (A0, A1, A2, A3, A4), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (A0, A1, A2, A3, A4), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(R (*pointer)(A0, A1, A2, A3, A4))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (*)(A0, A1, A2, A3, A4), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (*)(A0, A1, A2, A3, A4), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (*)(A0, A1, A2, A3, A4), void>::emptyCallback(A0, A1, A2, A3, A4)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>& Bind<R (*)(A0, A1, A2, A3, A4), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>& Bind<R (*)(A0, A1, A2, A3, A4), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>& Bind<R (*)(A0, A1, A2, A3, A4), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::emptyCallback(A0, A1, A2, A3, A4)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (A0, A1, A2, A3, A4, A5), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (A0, A1, A2, A3, A4, A5), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (A0, A1, A2, A3, A4, A5), void>::emptyCallback(A0, A1, A2, A3, A4, A5)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>& Bind<R (A0, A1, A2, A3, A4, A5), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>& Bind<R (A0, A1, A2, A3, A4, A5), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>& Bind<R (A0, A1, A2, A3, A4, A5), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::emptyCallback(A0, A1, A2, A3, A4, A5)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13), ArgGetterT<UserTypeT, A14>::Get(userdata, 14));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13), ArgGetterT<UserTypeT, A14>::Get(userdata, 14));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13), ArgGetterT<UserTypeT, A14>::Get(userdata, 14));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13), ArgGetterT<UserTypeT, A14>::Get(userdata, 14), 
				ArgGetterT<UserTypeT, A15>::Get(userdata, 15));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13), ArgGetterT<UserTypeT, A14>::Get(userdata, 14), 
				ArgGetterT<UserTypeT, A15>::Get(userdata, 15));
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& rhs)
		:pHolder(rhs.pHolder)
	{}


	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::Bind(const Yuni::DynamicLibrary::Symbol& symbol)	
	{
		bind(symbol);
	}



	// Destructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13), ArgGetterT<UserTypeT, A14>::Get(userdata, 14), 
				ArgGetterT<UserTypeT, A15>::Get(userdata, 15));
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






} // namespace Yuni

#endif // __YUNI_CORE_BIND_BIND_H__
